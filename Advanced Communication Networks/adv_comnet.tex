

% Advanced Topics in Communication Networks D-ITET
% ===========================================================================
% @Author: Noah Huetter
% @Date:   2019-09-24 17:26:28
% @Last Modified by:   noah
% @Last Modified time: 2020-02-04 11:01:20
% ---------------------------------------------------------------------------

\documentclass[a4paper, fontsize=8pt, landscape, DIV=1]{scrartcl}
\usepackage{lastpage}
\usepackage{hyperref}
% Include general settings and customized commands
\input{settings/general}
\input{settings/commands}

% This package makes formulas a bit more compact but less beautiful
% \usepackage{newtxtext,newtxmath}

% scala language description
\lstdefinelanguage{BNF}{%
    alsoletter={-},%
    sensitive,%
}[keywords,comments]%


% scala language description
\lstdefinelanguage{P4}{%
    sensitive,%
    backgroundcolor=\color{codeblue},%
%    morecomment=[l]//,%
%    morecomment=[s]{/*}{*/},%
}[keywords,comments]%

\definecolor{codeblue}{HTML}{DEF0FE}
\lstdefinestyle{P4style}{
    language=P4,%
    frame=none,%
    backgroundcolor=\color{codeblue},%
    keywords={action, action_function_declaration, action_profile, action_selector, algorithm, and, apply, attribute, attributes, bit, bytes, bytes_and_packets, calculated_field, control, counter, direct, dynamic_action_selection, else, extern, extern_type, extract, false, field_list, field_list_calculation, fields, header, header_type, hit, if, in, inout, input, instance_count, int, last, layout, mask, max, metadata, meter, method, min, min_width, miss, next, not, optional, or, output_width, packets, parse_error, parser, parser_drop, parser_exception, parser_value_set, primitive_action_declaration, range, register, result, return, saturating, select, selection_key, set_metadata, signed, static, table, true, update, valid, varbit, verify, width},%
    basicstyle=\ttfamily,%
    aboveskip=3mm,%
    belowskip=3mm,%
    fontadjust=true,%
    keepspaces=true,%
    keywordstyle=\bfseries,%
    captionpos=b,%
    framerule=0.3pt,%
    firstnumber=0,%
    numbersep=1.5mm,%
    numberstyle=\tiny,%
}
\lstset{%
    basicstyle=\ttfamily,%
%    language=P4,%
    aboveskip=3mm,%
    belowskip=3mm,%
    fontadjust=true,%
%    columns=[c]fixed,%
    keepspaces=true,%
%    commentstyle=\itshape,%
    keywordstyle=\bfseries,%
    captionpos=b,%
    framerule=0.3pt,%
    firstnumber=0,%
    numbersep=1.5mm,%
    numberstyle=\tiny,%
}

% \bibliography{semiconductordevices}
% \bibliographystyle{ieeetr}
\medmuskip=1mu

%change page style for header
\pagestyle{fancy}
\footskip 20pt

% Uncomment this line to make formulasheet ultra compact
% This removes
% - list of variables
% \newcommand{\makeultracompact}{irrelevant}
\let\makeultracompact\undefined

% Make stuff ultra compact if so desired
\ifdefined\makeultracompact
  \setlength{\parskip}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
\else
\fi
 
% -----------------------------------------------------------------------
\IfFileExists{../build/revision.tex}{
  \input{../build/revision.tex}
  \rhead{Compiled: \compiledate \hspace{1em} on: \hostname \hspace{1em} git-sha: \revision \hspace{1em} Noah Huetter}
}{\rhead{Noah Huetter}}

\ifdefined\makeultracompact
  \lhead{ETH Advanced Topics in Communication Networks 2019 \hspace{1em}compact version}
\else
  \lhead{ETH Advanced Topics in Communication Networks 2019}
\fi
\chead{\thepage}
\cfoot{}
\headheight 17pt \headsep 10pt
\title{ETH Advanced Topics in Communication Networks 2019}
\author{Noah Huetter}

\date{\today}
\begin{document}

\setcounter{page}{0}
\setcounter{secnumdepth}{2} %no enumeration of sections
\begin{multicols*}{4}
	\section*{Disclaimer}
	This summary is part of the lecture ``ETH Advanced Topics in Communication Networks'' (227-0575-00L) by Prof. Dr. Laurent Vanbever (FS19). It is based on the lecture slides 
  that can be found at \href{https://adv-net.ethz.ch/}{adv-net.ethz.ch}. \\[6pt]
	Please report errors to \href{mailto:huettern@student.ethz.ch}{huettern@student.ethz.ch} such that others can benefit as well.\\[6pt]	
  The upstream repository can be found at \href{https://github.com/noah95/formulasheets}{https://github.com/noah95/formulasheets}
	\vfill\null
  \columnbreak
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \setcounter{tocdepth}{2}
  \tableofcontents
  \vfill\null
  %\columnbreak
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pagebreak
  \maketitle 
  \setcounter{page}{1}
  \thispagestyle{fancy}


  % ---------------------------------------------------------------------------
  \section{Motivation}
  % ---------------------------------------------------------------------------
  Complexity + Low-level Management = Problems. Human factors are responsible
  for 50\% to 80\% of network outages. Solving problems used to be hard because
  network devices tend to be completely locked down.

  % ---------------------------------------------------------------------------
  \section{Software-Defined Networking}
  % ---------------------------------------------------------------------------
  A new approach to networking: Not about architecture (IP, TCP, etc.) but 
  about design of network control (routing, TE, ...). \textbf{Separates the
  control-plane from the data-plane}. It doesn't do much but enables a lot.

  \cgraphic{0.8}{img/sdntopo.png}

  \subsection{Advantages}
  \begin{itemize}
    \item Simpler management
    \item Faster pace of innovation
    \item Easier interoperability
    \item Simpler, cheaper equipment
  \end{itemize}

  % ---------------------------------------------------------------------------
  \section{OpenFlow}
  % ---------------------------------------------------------------------------
  OpenFlow is an API to a switch flow table. Match, action, priority.
  \cgraphic{0.8}{img/openflow.png}

  Enables different kinds of boxes:
  \begin{itemize}
    \item Router: Match LPM, Action: forward out a link
    \item Switch: Match destination MAC, Action: forward of flood
    \item Firewall: Match: IP, port, Action: permit or deny
  \end{itemize}

  \subsection{Example Applications}
  \begin{itemize}
    \item Dynamic access control
    \item Seamless mobility/migration
    \item Server load balancing
    \item ...
  \end{itemize}

  \subsection{Challenges}
  \begin{outline}
    \1 Heterogeneous Switches
      \2 Number of packet-handling rules
      \2 Range of matches and actions
    \1 Controller Delay and Overhead
      \2 Controller is much slower than the switch
      \2 Provessing packets leads to delay and overhead
      \2 Need to keep most packets n the "fast path"
    \1 Testing and Debugging
      \2 OpenFlow makes programming possible
      \2 Plenty of room for bugs
    \1 Programming Abstractions
      \2 OpenFlow is a loq-level API
      \2 Makes netowrk programming possible, not easy!
  \end{outline}

  \subsection{Disadvantages}
  \begin{outline}
    \1 Protocol is too complex:
    Switches must support complicated parsers and pipelines
    \1 The specificatino itself keeps getting more complex
    \1 Switches vendor end up implementing parts of the spec
  \end{outline}

  % ---------------------------------------------------------------------------
  \section{Protocol Independent Switch Architecture}
  % ---------------------------------------------------------------------------
  PISA: Protocol Independent Switch Architecture for high-speed programmable
  packet forwarding. By default PISA doesn't do anything, it's just an "architecture".
  \cgraphic{1}{img/pisa.png}

  PISA + P4 is strictly more general OpenFlow
  \cgraphic{1}{img/pisap4.png}

  % ---------------------------------------------------------------------------
  \section{P4}
  % ---------------------------------------------------------------------------
  \subsection{Structure}
  A P4 program consists of three basic parts: Parser, Match-Action Pipeline and
  Deparser. 

  \textbf{Parser} Programmer declares the headers that should be recognized and
  their order in the packet. 
  \textbf{Match-Action Pipeline} Programmer defines the tables and the processing
  logic.
  \textbf{Deparser} Programmer declares how the output packet will look on the wire.

  \subsection{Basic Building Blocks}
  The control consists of control flow, actions and tables.
  \textbf{control flow} describes how packets should be processed.
  \textbf{actions} fragments manipulating headers fields/metadata.
  \textbf{tables} map user-defined keys with actions.

  \cgraphic{1}{img/matchaction.png}

  \subsection{Environment}
  P4-16 introduces the concept of an architecture. The P4 Target is a model 
  of a specific hardware implementation and the P4 Architecture an API to
  program a target.

  \cgraphic{1}{img/p4env.png}  

  In this course, we'll rely on a simple P4-16 switch architecture \texttt{v1model}.
  Each architecture defines the \textbf{metadata} it supoprts, including both standard and 
  intrinsic ones. It also defines a list of "externs", ie. blackbox functions whose interface
  is known. Examples are:
  \begin{outline}
   \1 Registers
   \1 Random number generators
   \1 Hash functions
  \end{outline}

  \subsection{Language}
  P4-16 is a statically-typed language with base types and operators to derive composed ones.
  There exist no floating point variables, no division and modulo. Variables have local scope and
  their values is not maintained across subsequent invocations. They cannot be used to
  maintain state between different network packets. Instead you use tables or external
  objects.

  Loops are only possible during the parser stage. Parser contains advanced concepts such as
  verify (error handling), lokahead (access bits that are not parsed yet) and sub-parsers
  (like subroutines).

  \subsubsection{Tables}
  Can match on one or multiple keys in different ways. \texttt{exact}
  comparison, \texttt{ternary}: compare with mask, \texttt{lpm} longest prefix match.
  Architectures can add matches such as \texttt{range} in v1model.

  Tabe entries are added through the control plane.
  \cgraphic{1}{img/p4table.png}  
  
  \subsubsection{Actions}
  Are blocks of statements that possibly modify the packets. Usually take directional
  parameters indicating how the corresponding value is treated within the block.
  \texttt{in}: read only inside the action, \texttt{out}: Uninitialized, write inside action,
  \texttt{inout}: Combination. Actions parameters resulting from a table lookup do not 
  take a direction as they come from the control plane.

  \subsubsection{Control flow}
  Apllying a table \texttt{.apply()}, checking if there was a hit \texttt{.hit} and check which action was executed \texttt{.apply().action\_run}. Validating and computing checksums
  using externals. And more advanced concepts:
  \begin{outline}
   \1 Cloning packets
   \1 Sending packets to control plane
   \1 Recirculting (send packet through pipeline multiple times)
  \end{outline}

  \subsection{Keeping State}
  Registers can be used to store arbitrary data to keep track of state accross
  packet boundaries.

  Example of stateful firewall:
  \cgraphic{1}{img/statefulfirewall.png}

  \texttt{counter} can also be used, they cannot be read from the dataplane however.
  Counters can be attached to tables to count table entry hit count.

  \texttt{meter} can be used for rate-limiting. 

  \texttt{direct\_meter} can be associated with a table to count entries matched.

  \cgraphic{1}{img/statesummary.png}


  % ---------------------------------------------------------------------------
  \section{Probabilistic Data Structures}
  % ---------------------------------------------------------------------------
  We are provided with built-in stateful data structures such as arrays of registers, 
  counters or meters. We need to deal with severe limitations such as a limited
  number of operations and memory. \textbf{Today}: How can we implement a set with
  its usual methods? I.e., add an element, membership query, delete an element,
  lookup, listing.

  \begin{center}
  \begin{tabular}{l | c | c }
    {} & strategy 1 & strategy 2 \\ \hline
    output & Deterministic & Probabilistic \\
    number of ops & Probabilistic & Deterministic
  \end{tabular}
  \end{center}

  \subsection{Separate-chaining}
  Intuitive impleentation of a set. An input is hashed to yield a index from 0 to
  register size - 1. \textbf{Pro}: Accurate and fast in average case. \textbf{Con}:
  only works in hardware if there is a low number of elements (e.g. < 100).

  $N$ elements and $M$ cells.
  \begin{center}
  \begin{tabular}{l  c }
    {} & list size \\
    average & $N/M$ \\
    worst-case & $N$
  \end{tabular}
  \end{center}

  \subsubsection{Insertions}
  Hash the input value and set the bit at the hash location to $1$/$0$.
  \subsubsection{Membership query}
  Hash the input value and check the bit at the hash location. There could be
  false positives, if two input words result in the same hash value.

  $N$ elements and $M$ cells.
  \begin{center}
  \begin{tabularx}{\columnwidth}{X c}
  Prob. of element to be maped into particular cell & $\frac{1}{M}$ \\
  Prob. of element not to be mapped into particular cell & $1-\frac{1}{M}$ \\
  \textbf{False positive rate (FPR)} & $1 - (1-\frac{1}{M})^N$ \\
  False negative rate & $0$
  \end{tabularx}
  \end{center}

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = 1 - \left(1-\frac{1}{M}\right)^N
    \end{gathered}
  \end{empheq}

  E.g. for 1'000 elements into 10'000, FPR = 9.5\%.

  \textbf{Pro}: Simple and only one operation per insertion or query \textbf{Con}:
  Roughly 100x more cells are required than the number of elements we want to
  store for a 1\% FPR.

  \subsection{Bloom Filters}
  A more memory-efficient approach for insertions and membership queries. Use $K$ 
  hash functions to map $N$ elements into $M$ cells. For insertion set all cells
  of the $K$ hash values. An element is considered in the set if \textbf{all} the hash
  values map to a cell with $1$. An element is not in the set if \textbf{at least} one
  hash value maps to a cell with $0$.

  $N$ elements, $M$ cells and $K$ hash functions.
  \begin{center}
  \begin{tabularx}{\columnwidth}{X c}
  Prob. that one hash fun. returns idx of particular cell & $\frac{1}{M}$ \\
  Prob. that one hash fun. does not return idx of particular cell & $1-\frac{1}{M}$ \\
  Prob. of cell to be $0$ & $(1-\frac{1}{M})^{KN}$ \\
  \textbf{False positive rate (FPR)} & $(1 - (1-\frac{1}{M})^{KN})^K$ \\
  False negative rate & $0$
  \end{tabularx}
  \end{center}

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = \left(1 - \left(1-\frac{1}{M}\right)^{KN}\right)^K
    \end{gathered}
  \end{empheq}

  E.g. 1'000 elements, 10'000 cells, 7 hash functions 0.82\% FPR.

  \textbf{Pro}: Consumes roughly 10x less memory than the simple approach \textbf{Con}:
  Requires slightly more operations than the simple approach

  \subsubsection{Dimensioning}
  Is a tradeoff between memory, number of operations and false positive rate.

  $N$ elements\\
  $M$ cells\\
  $K$ hash functions \\
  $\text{FP}$ false positive rate
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} \approx \left(1 - e^{-KN/M}\right)^K
    \end{gathered}
  \end{empheq}

  There is always a global minimum when $N$, $M$ are given.
  \cgraphic{1}{img/bloomplot.png}

  \subsubsection{Implementation}
  Depending on hardware limitations, splitting the bloom filter might be required.
  $M$ cells are split into $M/K$ disjoint groups. An element is hashed to $K$ cells, 
  one in each group. One hash function per group. Same performance, may be easier
  to implement or parallelize.

  \subsubsection{Reset}
  Because deletions are not possible, the controller may need to regularly reset the
  bloom filters. Resetting a bloom filter takes some time during which it is not
  usable. Common trick: Use two bloom filters and use one when the controller resets
  the other one.

  \subsection{Counting Bloom Filters}
  Problem with Bloom Filters is that they cannot handle deletions. Counting Bloom
  Filters \textbf{increment} the corresponding counters on insertion and \textbf{decrement}
  upon deletion. All of the prior analysis applies to counting bloom filters.

  Counting Bloom Filters do handle deletions at the price of using more memory. Counters
  must be large enough to avoid overflow or else there are false negatives. Poisson
  approcimation suggests \textbf{4 bits/counter}.

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = \left(1 - \left(1-\frac{1}{M}\right)^{KN}\right)^K
    \end{gathered}
  \end{empheq}

  \subsection{Invertible Bloom Lookup Tables (IBLT)}
  IBLT store key-value pairs and allow for lookups and a complete listing. Each cell
  contains three fields: \\
  \textbf{count} which counts the number of entries mapped to this cell\\
  \textbf{keySum} is the sum of all keys mapped to this cell\\
  \textbf{valueSum} is the sum of all values mapped to this cell

  \subsubsection{Add}
  Assuming it is not in the set.
  \begin{outline}
   \1 For each hash function, hash the key to find the index. Then at this index
    \2 Increment the count by one
    \2 Add key to keySum
    \2 Add value to valueSum
  \end{outline}
  \cgraphic{0.6}{img/ibltinsert.png}

  \subsubsection{Delete}
  Assuming it is in the set.
  \begin{outline}
   \1 For each hash function, hash the key to find the index. Then at this index
    \2 Decrement the count by one
    \2 Subtract key to keySum
    \2 Subtract value to valueSum
  \end{outline}

  \subsubsection{Lookup}
  The value of a key can be found if the key is associated to at least one 
  cell with a count = 1.
  \cgraphic{0.6}{img/ibltlookup.png}

  \subsubsection{Listing}
  \begin{outline}
   \1 While there is an index for which count = 1
    \2 Find the corresponding key-value pair and return it
    \2 Delete the coresponding key-value pair
  \end{outline}
  Unless the number of iterations is very low, loops can not be implemeted 
  in hardware. The listing is done by the controller.

  \subsubsection{Tricks}
  In many settings, we can use XORs in place of sums for example to avoid
  overflow issues.

  \subsection{Sketches in General}
  Problem: Data stream with $n$ elements in totel, in the worst case $n$
  distinct elements and we want to count \textit{frequencies}, or how many
  times an element occurs. $n$ counter required would be memory inefficient.

  Sketches provide approximate frequencies of elements in a data stream. More 
  efficient by allowing mis-counting. Notation:
  \begin{empheq}{gather*}
    \vect{x} = \begin{bmatrix}x_1\\x_2\\\vdots\end{bmatrix}
  \end{empheq}
  Vector of frequencies (counts) of all distinct elements $x_i$.

  \subsection{CountMin sketch}
  Uses the same principles as a counting bloom filter, but is designed to have
  provable L1 error bounds for frequency queries.

  The estimation error exceeds $\norm{x}_1$ with a probability smaller than $\delta$:
  \begin{empheq}{gather*}
    \P(\hat{x}_i - x_i \geq \epsilon \norm{x}_1) \leq \delta
  \end{empheq}
  $\hat{x}_i$ Estimated frequency\\
  $x_i$ True frequency\\
  $\epsilon \norm{x}_1$ sum of frequencies.

  Let $\norm{x}_1=10000$, $\epsilon=0.01$, $\delta=0.05$: The probability for
  any estimat to be off by more than 100 is less than 5\% after counting 10000 elements.

  \subsubsection{Principle of Operation}
  $w\times d$ counters where $w$ inices per array is the range of hashes and $d$
  number of arrays with one hash function per array.
  \cgraphic{0.6}{img/cms.png}

  Count: Hash stream and increment the corresponding counter in each array.

  Query: Return the minimum value of the counters.

  \subsubsection{Error bounds}
  The proof is omitted and can be found in the lecture slides.
  
  Error bounds per hash/array:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \P(\hat{x}_i^{(h)} - x_i \geq \epsilon^{(h)}\norm{x}_1) \leq \delta^{(h)} \\
      \P(\hat{x}_i^{(h)} - x_i \geq \frac{c}{w}\norm{x}_1) \leq \frac{1}{c}
    \end{gathered}
  \end{empheq}
  $c$ from Markov inequality\\
  $w$ hash range\\
  $\hat{x}_i^{(h)}$ estimate for specific hash

  Error bounds for the minimum:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \P(\hat{x}_i - x_i \geq \frac{c}{w}\norm{x}_1) \leq \frac{1}{c^d}
    \end{gathered}
  \end{empheq}

  Optimal size:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \epsilon = \frac{c}{w} \leadsto w = \left\lceil\frac{c}{\epsilon}\right\rceil \\
      \delta = \frac{1}{c^d} \leadsto d = \left\lceil\log_c\frac{1}{\delta}\right\rceil
    \end{gathered}
  \end{empheq}
  $w$ hash range\\
  $d$ number of hashes

  Choosing $c=e$ minimizes the total number of counters.

  \subsubsection{Recipe}
  Choose:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      d = \left\lceil\ln\frac{1}{\delta}\right\rceil \quad w=\left\lceil\frac{e}{\epsilon}\right\rceil
    \end{gathered}
  \end{empheq}

  Then $\hat{x}_i-x_i\geq\epsilon\norm{x}_1$ with a probability less than $\delta$.

  \subsubsection{Summary}
  A CountMin sketch uses the same principles as a counting bloom filter, but is
  designed to have provable L1 error bounds for frequency queries. It is only one
  design out of many.

  \subsection{Count sketch}
  Uses the same principles as a counting bloom filter, but is designed to have 
  \textbf{provable L2 error bounds} for frequency queries.

  Extends CountMin sketch by $g: U\to\{+1,-1\}$. For count instead of increment,
  add $g(x_i)$ to the cell. For query instead of minimum, return median of $\text{reg}[h(x_i)]g(x_i)$

  \subsubsection{Recipe}
  Choose:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      d = \left\lceil\ln\frac{1}{\delta}\right\rceil \quad w=\left\lceil\frac{e}{\epsilon^2}\right\rceil
    \end{gathered}
  \end{empheq}

  Then $\hat{x}_i-x_i\geq\epsilon\norm{x}_2$ with a probability less than $\delta$.

  \subsection{Summary}
  Sketches compute statistiacl summaries, favoring elements with high frequency.
  Error relative to flow size is larger for smaller flows.

  Regardless of their limitations, sketches provide trade-offs between resources and error, and 
  provable gurarantees to rely on.

  % ---------------------------------------------------------------------------
  \vfill\null
  \pagebreak
  \end{multicols*}
  \begin{multicols*}{3}
  \section{P4 language}
  % ---------------------------------------------------------------------------
  \subsection{Data types}

  \subsubsection{Base types}

  \begin{tabularx}{\linewidth}{ l X}
    \lstinline[style=P4style]!bool! &
    Boolean value\\
    \lstinline[style=P4style]!bit<W>! &
    Bit-string of width \texttt{W}\\
    \lstinline[style=P4style]!int<W>! &
    Signed integer of width \texttt{W}\\
    \lstinline[style=P4style]!varbit<W>! &
    Bit-string of dynamiv length \texttt{<=W}\\
    \lstinline[style=P4style]!match_kind! &
    describes ways to match table keys\\
    \lstinline[style=P4style]!error! &
    used to signal errors\\
    \lstinline[style=P4style]!void! &
    no values, used in few restricted circumstances\\
  \end{tabularx}

  \subsubsection{Header}
  Parsing a packet using \texttt{extract()} fills in the fields of the header.
  A successful \texttt{extract()} sets to true the validity bit of the extraced header.

  \begin{lstlisting}[style=P4style]
action:
header Ethernet_h {
  bit<48> dstAddr;
  bit<48> srcAddr;
  bit<16> etherType;
}
Ethernet_h ethernetHeader;
\end{lstlisting}

  \subsubsection{Header Stack}
  Array of up to \texttt{N} headers of type \texttt{Mpls\_h}.

\begin{lstlisting}[style=P4style]
header Mpls_h {
  bit<20> label;
  bit<3>  tc;
  bit     bos;
  bit<8>  ttl;
}
Mpls_h[10] mpls;
\end{lstlisting}

  \subsubsection{Header union}
Either \texttt{IPv4} or \texttt{IPv6} header is present.

\begin{lstlisting}[style=P4style]
header_union IP_h {
 IPv4_h v4;
 IPv6_h v6;
}
\end{lstlisting}


  \subsubsection{Struct}
  Unordered collection of named members.

\begin{lstlisting}[style=P4style]
struct standard_metadata_t {
 bit<9> ingress_port;
 bit<9> egress_spec;
 bit<9> egress_port;
 ...
}
\end{lstlisting}

  \subsubsection{Tuple}
  Unordered collection of unnamed members.

\begin{lstlisting}[style=P4style]
tuple<bit<32>, bool> x;
x = { 10, false }
\end{lstlisting}

  \subsubsection{Other}
  \begin{tabularx}{\linewidth}{ l X}
  \lstinline[style=P4style]!enum Prio \{High, Low\}! &
  Enumeration \\
  \lstinline[style=P4style]!typedef bit<48> macAddr_t! &
  Create subtypes \\
  \lstinline[style=P4style]!extern! &
  {}  \\
  \lstinline[style=P4style]!parser! &
  {}  \\
  \lstinline[style=P4style]!control! &
  {}  \\
  \lstinline[style=P4style]!package! &
  {}  \\
  \end{tabularx}

  \subsection{Data structures}

  \begin{lstlisting}[style=P4style]
struct standard_metadata_t {
  bit<9>  ingress_port;
  bit<9>  egress_spec;
  bit<9>  egress_port;
  bit<32> instance_type;
  bit<32> packet_length;
  bit<32> enq_timestamp;
  bit<19> enq_qdepth;
  bit<32> deq_timedelta;
  bit<19> deq_qdepth;

  // intrinsic to metadata v1model
  bit<48> ingress_global_timestamp;
  bit<48> egress_global_timestamp;
  bit<16> mcast_grp;
  bit<16> egress_rid;
  bit<1>  checksum_error;
  error parser_error;
  bit<3> priority;
}\end{lstlisting}

\begin{tabularx}{\linewidth}{ l X }
  \lstinline[style=P4style]!ingress_port! &
  Port the packet was received \\
  \lstinline[style=P4style]!egress_spec! &
  Port where the packet will be transmitted \\
\end{tabularx}

  \subsection{Examples}

  \subsubsection{Multicast group ID}
  For a L2-switch to work, it has to multicast packets. Simple switch has a multicast features that
  allows setting a metadata field so that packets are sent to multiple ports.

  First, on the switch, create a multicast group, node and assign these.
  \begin{lstlisting}[language=bash]
mc_mgrp_create <mcast_grp_id>
mc_node_create <replication_id> <port_number> [port_number]
mc_node_associate <mcast_grp_id> <node_handle_id>\end{lstlisting}
  \texttt{mc\_node\_create} returns the \texttt{node\_handle\_id}. For every \texttt{replication\_id} the \texttt{mc\_node\_create} is incremented.

  Example: Mulcicast \texttt{mcast\_grp\_id=1} with \texttt{replication\_id=0} on ports \texttt{1,2,3,4} 
  \begin{lstlisting}[language=bash]
mc_mgrp_create 1
mc_node_create 0 1 2 3 4
mc_node_associate 1 0\end{lstlisting}

  To send a packet to this group, in P4 set the \texttt{standard\_metadata.mcast\_grp} to \texttt{mcast\_grp\_id} during the ingress pipeline.

  \subsubsection{Cloning Packets}
  Is a feature of simple switch.

  Configure the switch with a mirroring session \texttt{session} mapped to an \texttt{output\_port}.
  \begin{lstlisting}[style=P4style]
mirroring_add <session> <output_port>\end{lstlisting}

  During ingress pipeline, a packet can be cloned using \texttt{clone}. The packet will be cloned to the egress pipeline and port configured by \texttt{mirroring\_add}. When using \texttt{clone3} you can add as a third parameter a metadata \texttt{struct}.
  \begin{lstlisting}[style=P4style]
clone(CloneType.I2E, <session>)
// Generally
clone(in CloneType type, in bit<32> session)
clone3<T>(in CloneType type, in bit<32> session, in T data)\end{lstlisting}

  To identify a cloned packet in the egress pipeline, check the \texttt{standard\_metadata.instance\_type==1} field.

  When a packet is cloned all its metadata fields
  are reset to the default value (usually 0).


  \subsubsection{Digest packets}
  A feature of simple switch to send packets to the controller without having to clone it.

  \begin{lstlisting}[style=P4style]
// Define a struct that is sent to the controller
struct learn_t {
    macAddr_t srcAddr;
    inPort_t  inPort;
}
// Add the struct to the metadata
struct metadata {
    /* empty */
    //TODO 3: delcare one learn_t variable
    learn_t learn;
}
// fill in the meatdata fields
meta.learn.srcAddr = hdr.ethernet.srcAddr;
meta.learn.inPort = (inPort_t)standard_metadata.ingress_port;
// send to the controller
// nothing else has to be done
digest(1, meta.learn); // first argument is always 1\end{lstlisting}

  
\end{multicols*}

\setcounter{secnumdepth}{2}
\end{document}
